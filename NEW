Мы должны корректно определять где данные являются не словарем, а только псевдо-массивом.


Как определяются схожие паттерны: в add object у нас уже есть данные по которым мы можем прогнать наши паттерны, в случае обьединения схем, мы берем из нашей базы паттерной их атрибут "примеры" и прогоняем для паттернов в предоставленной схеме, считать что если паттерн схемы прошел примеры нашего паттерна, то паттерн схемы эквивалентен. Дальше, получив набор данных (из примеров или реальные) мы ищем наиболее строгий паттерн, комбинируя данные при этом (чтобы найти места с общими паттернами, пусть менее строгими чем по отдельности).


Обязательные поля в итоговой схеме:

1. комментарий, поясняющий что это за паттерн

2. список отброшенных паттернов (отброшенным считать исключительно паттерны не прошедшие отбор по экземплярным данным, если у них только ниже приоритет - туда они не попадают). В следующих итерация алгоритма, при обьединении add_schema этот черный список должен учитываться при выборе паттерна или его отцуцтвия


Правила:

1. Паттерны создаются лишь у json данных при конвертации в схему (за исключением случаев, когда мы обьединяемся с готовой схемой, которая говорит что паттерна там нет). При генерации из json все пустые словари (если нет ни одного варианта где у них есть содержимое) должны помечаться как пустые.

2. По возможности при обьединении мы ищем общие паттерны, допускается в таких случаях снижение строгости общего паттерна, если он есть в списке доступных

3. Если какие-то паттерны невозможно обьединить, мы помещаем их в oneOf

4. Если при объединении паттернов, у нас есть пустой кандидат (пустой помечанные словарь) - мы просто его отбрасываем.

5. Если при объединении паттернов у нас есть не-паттерный не-пустой кандидат, мы отбрасываем все паттерны