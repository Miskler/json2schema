# json2schema

# Идея

Есть глобальный менеджер который агрегирует кандидатов и проводит рекурсивную обработку.

Обработка идет следующим образом: снизу вверх идет обход всех схем/json, они в порядке приоритета предоставляются
на обратку компараторам, которые проводят необходимые операции и отдают слой (они все не видят схему глобально, работают лишь со своим слоем).

Правила глобальные задают:
Приоритет и список компараторов

Дальше компараторы по приоритету получают сначало вопрос: "ты будешь что-то обрабатывать?".
Если ответ положительный - они могут вернуть список компараторов, которым в дальнейшем НЕЛЬЗЯ обрабатывать этот слой.
Дальше если был положительный ответ - вызывается функция обработки слоя. Функции компаратора всегда передуют:
1. list объект-ресурса кандидатов-схем
2. list объект-ресурса кандидатов-json
3. результат обработки прошлых слоев (если нет то {})
4. env-путь (например property/anyOf/pattern/property)
Оба списка уже распарсены до нужного уровня вложенности

Объект ресурс имеет:
content, id, type=json/schema

Функция возвращает:
Результат ее обработки словарь, 
ЕСЛИ есть Of атрибуты (any,all,one) то в них всегда проставляется технический атрибут `"j2sElementTrigger"=[объект-ресурса.id]`
Этот атрибут говорит о том, какие данные послужили триггером для создания этого ветвления. Например:
```py
converter.add_schema({ # id=0
    "type": "object",
    "properties": {
        "name": {"type": "integer"}
    }
})
converter.add_schema({ # id=1
    "type": "object",
    "properties": {
        "name": {"type": "string"}
    }
})
converter.add_json({"name": "Bob"}) # id=2
```
Тогда когда отработает TypeCompare он укажет:
```json
{
    "type": "object",
    "properties": {
        "name": {
            "anyOf": [
                {"type": "string",
                 "j2sElementTrigger": [1, 2]},
                {"type": "integer",
                 "j2sElementTrigger": [0]}
            ]
        }
    }
}
```
Следующий компаратор, если он посчитает что 0 и 1 элементы данных можно объединить - ему запретит его внутренний универсальный для всех компараторов
метод get_elements_triggers() -> [[0], [1, 2]]. Он кстати проходится не только по anyOf, но еще и по oneOf, allOf и объединяет всю собранную информацию в едино. То есть если нужно прописать атрибут 0 и 1 то он их продублирует в оба места, а если атрибут нужен 2 то он автомачиски дается и 1 (так как в одной группе).
Либо, если 1 и 2 противоречят, то он опять их раздвоит и продублирует атрибуты существующие в оба места, а дальше добавит свои.

После того как все компараторы отработают, код переходит на следующий уровень через properties и items[*], в том числе и в Of где применимо
